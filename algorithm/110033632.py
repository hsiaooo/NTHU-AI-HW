# -*- coding: utf-8 -*-
"""110033632.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YWz5gpZS7hUmg10yz8tGS3s1QTszziS5

#**Introduction to AI - Algorithm and Data Structure: An Exercise**
* Only **Python** implementation will be accepted.
* **DO NOT PLAGIARIZE.** (We will check program similarity.)
* You must **save as a copy** of this colab file before you start, otherwise your changes won't be saved.
* **You must upload a `.ipynb` and a `.py` files to [eeclass](https://eeclass.nthu.edu.tw/) for evaluation.**
<br /><br />

##**Submission**

* Due day: **2021.10.12**
* Files to submit
  * **StudentID.ipynb** file which contains all the results and code for this assignment.
  * **StudentID.py** the code in this file must be consistent with your `.ipynb` file.
* When you're done, you can download the `.py` and `.ipynb` by
  * "File" > "Download" > "Download .ipynb"
  * "File" > "Download" > "Download .py"

##**Tasks**
* (Required)
  * Complete the code in **\[T1\]**.
  * Complete the code in **\[T2\]**.
  * Answer the questions in **\[T3\]**.
* (Bonus)
  * Complete both **\[B1.1\]** and **\[B1.2\]** to earn bonus.


<br />

* * *

<br />

## **A Breifing**
From the previous practices, you've learned the basics of the data structures `queue` and `stack`. In this part, we are going to investigate and analyze their performance.

Now, I've implemented these data structures as classes for you. I would suggest you study and understand the code before you proceed.
"""

class ListLike:
  def __init__(self):
    self.content = []

  def __str__(self):
    return str(self.content)

  def __len__(self):
    return len(self.content)


class Queue(ListLike):
  def push(self, item):
    self.content.insert(0, item)
    return self

  def pop(self):
    if len(self) > 0:
      to_return = self.content[-1]
      self.content = self.content[:-1]
      return to_return
    else:
      raise IndexError("There's nothing to pop.")


class Stack(ListLike):
  def push(self, item):
    self.content.append(item)
    return self

  def pop(self):
    if len(self) > 0:
      to_return = self.content[-1]
      self.content = self.content[:-1]
      return to_return
    else:
      raise IndexError("There's nothing to pop.")

"""#### **[T1] Please complete this block to evaluate the performance of the class `queue`.**"""

import time
import random

lb, ub = 0, 100
k = int(1e5)

# Generate `k` random integers between `lb` and `ub`
randlist = [random.randint(lb, ub) for i in range(k)]

# Get an instance of the class `Quere`
queue = Queue()

# Get start time
start_time = time.time()

# Use a loop to push the `k` random integers to the `queue` ONE BY ONE.
for i in randlist:
  queue.push(i)

#  print(queue)    # <= uncomment this line if you need to print the queue

# Pop everything out of the queue. Again, pop them out ONE BY ONE.
for _ in range(len(queue)):
  queue.pop()

# Get end time
end_time = time.time()

# Compute and print elapsed time
print("It took %s seconds to push and pop %d items from a queue." % ((end_time - start_time), k))

"""#### **[T2] Please complete this block to evaluate the performance of the class `stack`.**"""

# Get an instance of the class `Quere`
stack = Stack()
times = 0

# Get start time
start_time = time.time()

# Use a loop to push the `k` random integers to the `stack` ONE BY ONE.
for j in randlist:
  stack.push(j)

# print(stack)    # <= uncomment this line if you need to print the stack

# Pop everything out of the stack. Again, pop them out ONE BY ONE.
for z in range(len(stack)):
  stack.pop()

# Get end time
end_time = time.time()

# Compute and print elapsed time
print("It took %s seconds to push and pop %d items from a stack." % ((end_time - start_time), k))

"""#### **[T3] Discussions**
You are expected to answer the following questions.

1. Which data structure runs faster in the above tests?
1. Why does the faster one run faster?
1. Analyze the **big-O** complexity of the `push` function of the two data structures in terms of **numbers of copies**. Namely, given a list of `n` elements, how many data copies (assignments) are required to `push` a item to a `queue` and to a `stack` in worst case? <br /> **Hint:** Moving an element in a list to another slot is one data copy.
1. In what case would you use a `queue` and `stack` to store data, repectively?
1. How can we improve the slower data structure?

Hint: You may see Python official document of [`List`](https://docs.python.org/3/tutorial/datastructures.html) for some clues.

You're answers (you may answer in Chinese):

**Ans. 1:** 
> `Stack` (spent time: 15.71s)

**Ans. 2:** 
> 在`queue`執行時，在`push`的執行約3s，而在`stack`的`push`執行不到1s左右，其因`queue`的`push`使用`insert`，所以每一次都要先去搜尋index在insert item後，要將所有以插入的資料往後移位，故時間複雜度較高，而`stack`使用append可以直接插入在最後一個，故`stack` faster than `queue`.

**Ans. 3:** 
> `push` function of `queue`: O(n). `push` function of `stack`: O(1). 

**Ans. 4:** 
> 通常會在需要data一個一個使用的時候使用`queue`，能夠讓資料暫時先儲存起來在一個一個往下送，避免資料遺失。<br />通常在需要比對兩項資料的時候可以使用`stack`，因`stack`遵守LIFO故可以進行比對。

**Ans. 5:** 
> 1) 將一開始queue的push function改為append的方式從後面增加item，這樣就不會有資料向後移位的問題，並在pop的時候提取第一位。**(從18s進步到15s)**<br />
2) 將list轉成linkedlist，這樣就不用每一次將儲存的資料往後移一位，而是可以直接跟著而是可以直接跟著pointer，隨時向下一位進行pop，大大的減少運行時間。

#### **[B1.1] Please revise this block according to your Answer 5.**
Please revise the following code according to your answer to improve the slower data structure.

Note that
*   a `queue` must follow `FIFO` rule
*   a `stack` must follow `LIFO` rule.

See supplementary materials on [eeclass](https://eeclass.nthu.edu.tw/) if you don't know what are these.
"""

class ListLike:
  def __init__(self):
    self.content = []

  def __str__(self):
    return str(self.content)

  def __len__(self):
    return len(self.content)


class Queue(ListLike):
  def push(self, item):
    self.content.append(item)
    return self

  def pop(self):
    if len(self) > 0:
      to_return = self.content[0]
      self.content = self.content[1:]
      return to_return
    else:
      raise IndexError("There's nothing to pop.")


class Stack(ListLike):
  def push(self, item):
    """
    Revise this method (function) if you answered that `Stack` is slower.
    """
    self.content.append(item)
    return self

  def pop(self):
    """
    And this method (function) too.
    """
    if len(self) > 0:
      to_return = self.content[-1]
      self.content = self.content[:-1]
      return to_return
    else:
      raise IndexError("There's nothing to pop.")

"""**[B1.2]** Copy your code from above to evaluate how much your revision improves the performance."""

import time
import random

lb, ub = 0, 100
k = int(1e5)

# Generate `k` random integers between `lb` and `ub`
randlist = [random.randint(lb, ub) for i in range(k)]

# Get an instance of the class `Quere` or `Stack
queue = Queue()   # <= uncomment this line if you want to test a `queue`
# stack = Stack()   # <= uncomment this line if you want to test a `stack`

# Get start time
start_time = time.time()

# Use a loop to push the `k` random integers to the `queue` or `stack` one by one.
for i in randlist:
  queue.push(i)

# print(queue)    # <= uncomment this line if you need to print the queue
# print(stack)    # <= uncomment this line if you need to print the stack

# Pop everything out of the queue or stack one by one.
for _ in range(len(queue)):
  queue.pop()

# Get end time
end_time = time.time()

# Compute and print elapsed time
print("It took %s seconds to push and pop %d items from a queue." % ((end_time - start_time), k))